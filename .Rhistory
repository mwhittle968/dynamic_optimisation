mutate(repro = ifelse(time.step %in% seq(from = 21, to = 61, by = 4), "yes", "no"))%>%
mutate(N = ifelse(stage == "pupae", 0, n))%>%
mutate(mh = ifelse(stage == "pupae", mh.pupae, mh.adult), ms = ifelse(stage == "pupae", ms.pupae, ms.adult))%>%
mutate(ex.surv = ifelse(stage == "pupae", ex.surv.pupae, ex.surv.adult))%>%
mutate(nh.crit = ifelse(stage == "pupae", nh.crit.pupae, nh.crit.adult))
remove(P)
S(3, 11)
B(3, 5, 6)
B(3, 5, 21)
B(8, 5, 21)
nh = 8
t = 21
F$repro[t] == "no" | nh < nh.repro | ns < ns.repro
ns = 5
F$repro[t] == "no" | nh < nh.repro | ns < ns.repro
nh.larva = (nh-F$mh[t])*nh.larva
nh.larva
ns.larva = (ns-F$ms[t])*ns.larva
ns.larva
B.nh = (m*nh.larva)-m*(nh.repro-F$mh[t])*nh.larva
B.nh
m*nh.larva
nh.repro-F$mh[t]
B <- function(nh, ns, t){
if (F$repro[t] == "no" | nh < nh.repro | ns < ns.repro){
B = 0
} else {# If it's a reproductive time step  and the reserves are sufficient the fitness is calculated
nh.l = (nh-F$mh[t])*nh.larva # Mother gives some of her reserves to larva
ns.l = (ns-F$ms[t])*ns.larva
B.nh = (m*nh.l)-m*(nh.repro-F$mh[t])*nh.larva # linear by nh
B.ns = ifelse(ns < (ns.repro-F$ms[t])*ns.larva, 0, 1) # step function by ns
B = B.nh*B.ns
}
return(B)
}
B(8, 5, 21)
maintenance(3)
investment(3, 2)
regulation(3, 2)
regulation(3, 7)
production(3)
new.state(3, 3, 3, 21,5)
pb <- txtProgressBar(min = 0, max = ns.max*nh.max*s.max*(T-1), style = 3)
V <- array(data = NA, dim = c((T), nh.max, ns.max, s.max)) # Empty fitness array, to be populated with values from T back to 1
d.opt <- array(data = NA, dim = c((T-1), nh.max, ns.max, s.max)) # Empty array for best decisions at each state and time
V[T,,,] <- 0 # terminal fitness function
for (t in (T-1):1){ # Iterates backwards in time
for (nh in 1:nh.max){
for (ns in 1:ns.max){
for (s in 1:s.max){
H = array(data = NA, dim = (2*N+1)) # Empty reproductive value array (for one state)
for (d in 1:(2*N+1)){
nh. = as.numeric(new.state(nh, ns, s, t, d)[1]) # Calculate new values for states
ns. = as.numeric(new.state(nh, ns, s, t, d)[2])
s. = as.numeric(new.state(nh, ns, s, t, d)[3])
H[d] = B(nh, ns, t) + S(nh., t)*interpolate(V, chop(nh., 1, nh.max), chop(ns., 1, ns.max), chop(s., 1, s.max), (t+1))
}
V[t, nh, ns, s] <- max(H) # define fitness as maximum of the reproductive values
d.opt[t, nh, ns, s] <- which.max(H) # Set best decision as the one which maximises fitness
setTxtProgressBar(pb, (s-1) + (ns-1)*s.max + (nh-1)*ns.max*s.max + (T-t-1)*nh.max*ns.max*s.max)
}
}
}
}
pb <- txtProgressBar(min = 0, max = ns.max*nh.max*s.max*(T-1), style = 3)
V <- array(data = NA, dim = c((T), nh.max, ns.max, s.max)) # Empty fitness array, to be populated with values from T back to 1
d.opt <- array(data = NA, dim = c((T-1), nh.max, ns.max, s.max)) # Empty array for best decisions at each state and time
V[T,,,] <- 0 # terminal fitness function
for (t in (T-1):1){ # Iterates backwards in time
for (nh in 1:nh.max){
for (ns in 1:ns.max){
for (s in 1:s.max){
H = array(data = NA, dim = (2*n+1)) # Empty reproductive value array (for one state)
for (d in 1:(2*n+1)){
nh. = as.numeric(new.state(nh, ns, s, t, d)[1]) # Calculate new values for states
ns. = as.numeric(new.state(nh, ns, s, t, d)[2])
s. = as.numeric(new.state(nh, ns, s, t, d)[3])
H[d] = B(nh, ns, t) + S(nh., t)*interpolate(V, chop(nh., 1, nh.max), chop(ns., 1, ns.max), chop(s., 1, s.max), (t+1))
}
V[t, nh, ns, s] <- max(H) # define fitness as maximum of the reproductive values
d.opt[t, nh, ns, s] <- which.max(H) # Set best decision as the one which maximises fitness
setTxtProgressBar(pb, (s-1) + (ns-1)*s.max + (nh-1)*ns.max*s.max + (T-t-1)*nh.max*ns.max*s.max)
}
}
}
}
d.opt <- melt(d.opt)
names(d.opt) <- c("time.step", "Nh", "Ns", "sym.pop", "decision")
plot <- ggplot(data = d.opt, aes(time.step, sym.pop, fill = decision)) +
geom_tile()+
facet_grid(Nh ~ Ns)+
scale_fill_gradient(low = "#80CBC4", high = "#00695C")+
theme(axis.title.y.right = element_text("Nh"),
axis.title.x.top = element_text("Ns"))
d.opt.plot
d.opt <- melt(d.opt)
names(d.opt) <- c("time.step", "Nh", "Ns", "sym.pop", "decision")
d.opt.plot <- ggplot(data = d.opt, aes(time.step, sym.pop, fill = decision)) +
geom_tile()+
facet_grid(Nh ~ Ns)+
scale_fill_gradient(low = "#80CBC4", high = "#00695C")+
theme(axis.title.y.right = element_text("Nh"),
axis.title.x.top = element_text("Ns"))
d.opt.plot
sim.plot <- ggplot(NULL, aes(x = time.step, y = sym.pop)) # empty plot to be populated with simulation runs
for (i in 1:I){
sim <- data.frame(time.step = integer(), nh.reserves = integer(), ns.reserves = integer(), sym.pop = integer(), decision = integer())%>%
# empty data frame to be populated with state values and allocations
add_row(time.step = 1,  nh.reserves = chop(round(rnorm(1, mean = (nh.max), sd = 0.5)), 0, nh.max),
ns.reserves = chop(round(rnorm(1, mean = (ns.max/2), sd = 0.5)), 0, ns.max),
sym.pop = chop(round(rnorm(1, mean = (s.max/3), sd = 0.5)), 0, s.max), decision = NA) # initial state values chosen at random
for (t in 1:(T-1)){
if (sim$nh.reserves[t] >= nh.crit & sim$ns.reserves[t] >= 1 & sim$sym.pop[t] >= 1){
d = interpolate(data, sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t) # extract optimum allocation amount based on state values
sim$decision[t] = d
nh. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[1])
ns. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[2])
s. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[3])
sim <- add_row(sim, time.step = (t+1), nh.reserves = nh., ns.reserves = ns., sym.pop = s., decision = NA) # populate data frame with new state values
print(t)}
else {
break # if reserves get to zero, stop the simulation
}
}
print(sim)
sim.plot <- sim.plot+
geom_line(data = sim, aes(x = time.step, y = sym.pop, group = 1)) # add data frame to plot
}
sim.plot <- sim.plot+
labs(x = "time step", y = "symbiont density")
sim.plot <- ggplot(NULL, aes(x = time.step, y = sym.pop)) # empty plot to be populated with simulation runs
for (i in 1:I){
sim <- data.frame(time.step = integer(), nh.reserves = integer(), ns.reserves = integer(), sym.pop = integer(), decision = integer())%>%
# empty data frame to be populated with state values and allocations
add_row(time.step = 1,  nh.reserves = chop(round(rnorm(1, mean = (nh.max), sd = 0.5)), 0, nh.max),
ns.reserves = chop(round(rnorm(1, mean = (ns.max/2), sd = 0.5)), 0, ns.max),
sym.pop = chop(round(rnorm(1, mean = (s.max/3), sd = 0.5)), 0, s.max), decision = NA) # initial state values chosen at random
for (t in 1:(T-1)){
if (sim$nh.reserves[t] >= F$nh.crit[t] & sim$ns.reserves[t] >= 1 & sim$sym.pop[t] >= 1){
d = interpolate(data, sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t) # extract optimum allocation amount based on state values
sim$decision[t] = d
nh. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[1])
ns. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[2])
s. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[3])
sim <- add_row(sim, time.step = (t+1), nh.reserves = nh., ns.reserves = ns., sym.pop = s., decision = NA) # populate data frame with new state values
print(t)}
else {
break # if reserves get to zero, stop the simulation
}
}
print(sim)
sim.plot <- sim.plot+
geom_line(data = sim, aes(x = time.step, y = sym.pop, group = 1)) # add data frame to plot
}
sim.plot <- sim.plot+
labs(x = "time step", y = "symbiont density")
i = 1
t = 1
sim <- data.frame(time.step = integer(), nh.reserves = integer(), ns.reserves = integer(), sym.pop = integer(), decision = integer())%>%
# empty data frame to be populated with state values and allocations
add_row(time.step = 1,  nh.reserves = chop(round(rnorm(1, mean = (nh.max), sd = 0.5)), 0, nh.max),
ns.reserves = chop(round(rnorm(1, mean = (ns.max/2), sd = 0.5)), 0, ns.max),
sym.pop = chop(round(rnorm(1, mean = (s.max/3), sd = 0.5)), 0, s.max), decision = NA) # initial state values chosen at random
sim$nh.reserves[t] >= F$nh.crit[t] & sim$ns.reserves[t] >= 1 & sim$sym.pop[t] >= 1
d = interpolate(data, sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t) # extract optimum allocation amount based on state values
d = interpolate(d.opt, sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t) # extract optimum allocation amount based on state values
sim
pb <- txtProgressBar(min = 0, max = ns.max*nh.max*s.max*(T-1), style = 3)
V <- array(data = NA, dim = c((T), nh.max, ns.max, s.max)) # Empty fitness array, to be populated with values from T back to 1
d.opt <- array(data = NA, dim = c((T-1), nh.max, ns.max, s.max)) # Empty array for best decisions at each state and time
V[T,,,] <- 0 # terminal fitness function
for (t in (T-1):1){ # Iterates backwards in time
for (nh in 1:nh.max){
for (ns in 1:ns.max){
for (s in 1:s.max){
H = array(data = NA, dim = (2*n+1)) # Empty reproductive value array (for one state)
for (d in 1:(2*n+1)){
nh. = as.numeric(new.state(nh, ns, s, t, d)[1]) # Calculate new values for states
ns. = as.numeric(new.state(nh, ns, s, t, d)[2])
s. = as.numeric(new.state(nh, ns, s, t, d)[3])
H[d] = B(nh, ns, t) + S(nh., t)*interpolate(V, chop(nh., 1, nh.max), chop(ns., 1, ns.max), chop(s., 1, s.max), (t+1))
}
V[t, nh, ns, s] <- max(H) # define fitness as maximum of the reproductive values
d.opt[t, nh, ns, s] <- which.max(H) # Set best decision as the one which maximises fitness
setTxtProgressBar(pb, (s-1) + (ns-1)*s.max + (nh-1)*ns.max*s.max + (T-t-1)*nh.max*ns.max*s.max)
}
}
}
}
interpolate(d.opt, sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t)
sim.plot <- ggplot(NULL, aes(x = time.step, y = sym.pop)) # empty plot to be populated with simulation runs
for (i in 1:I){
sim <- data.frame(time.step = integer(), nh.reserves = integer(), ns.reserves = integer(), sym.pop = integer(), decision = integer())%>%
# empty data frame to be populated with state values and allocations
add_row(time.step = 1,  nh.reserves = chop(round(rnorm(1, mean = (nh.max), sd = 0.5)), 0, nh.max),
ns.reserves = chop(round(rnorm(1, mean = (ns.max/2), sd = 0.5)), 0, ns.max),
sym.pop = chop(round(rnorm(1, mean = (s.max/3), sd = 0.5)), 0, s.max), decision = NA) # initial state values chosen at random
for (t in 1:(T-1)){
if (sim$nh.reserves[t] >= F$nh.crit[t] & sim$ns.reserves[t] >= 1 & sim$sym.pop[t] >= 1){
d = interpolate(d.opt, sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t) # extract optimum allocation amount based on state values
sim$decision[t] = d
nh. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[1])
ns. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[2])
s. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[3])
sim <- add_row(sim, time.step = (t+1), nh.reserves = nh., ns.reserves = ns., sym.pop = s., decision = NA) # populate data frame with new state values
print(t)}
else {
break # if reserves get to zero, stop the simulation
}
}
print(sim)
sim.plot <- sim.plot+
geom_line(data = sim, aes(x = time.step, y = sym.pop, group = 1)) # add data frame to plot
}
sim.plot <- sim.plot+
labs(x = "time step", y = "symbiont density")
d.opt. <- melt(d.opt)
names(d.opt.) <- c("time.step", "Nh", "Ns", "sym.pop", "decision")
d.opt.plot <- ggplot(data = d.opt., aes(time.step, sym.pop, fill = decision)) +
geom_tile()+
facet_grid(Nh ~ Ns)+
scale_fill_gradient(low = "#80CBC4", high = "#00695C")+
theme(axis.title.y.right = element_text("Nh"),
axis.title.x.top = element_text("Ns"))
d.opt.plot
sim.plot <- ggplot(NULL, aes(x = time.step, y = sym.pop)) # empty plot to be populated with simulation runs
for (i in 1:I){
sim <- data.frame(time.step = integer(), nh.reserves = integer(), ns.reserves = integer(), sym.pop = integer(), decision = integer())%>%
# empty data frame to be populated with state values and allocations
add_row(time.step = 1,  nh.reserves = chop(round(rnorm(1, mean = (nh.max), sd = 0.5)), 0, nh.max),
ns.reserves = chop(round(rnorm(1, mean = (ns.max/2), sd = 0.5)), 0, ns.max),
sym.pop = chop(round(rnorm(1, mean = (s.max/3), sd = 0.5)), 0, s.max), decision = NA) # initial state values chosen at random
for (t in 1:(T-1)){
if (sim$nh.reserves[t] >= F$nh.crit[t] & sim$ns.reserves[t] >= 1 & sim$sym.pop[t] >= 1){
d = interpolate(d.opt, sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t) # extract optimum allocation amount based on state values
sim$decision[t] = d
nh. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[1])
ns. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[2])
s. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[3])
sim <- add_row(sim, time.step = (t+1), nh.reserves = nh., ns.reserves = ns., sym.pop = s., decision = NA) # populate data frame with new state values
print(t)}
else {
break # if reserves get to zero, stop the simulation
}
}
print(sim)
sim.plot <- sim.plot+
geom_line(data = sim, aes(x = time.step, y = sym.pop, group = 1)) # add data frame to plot
}
sim.plot <- sim.plot+
labs(x = "time step", y = "symbiont density")
sim.plot
sim
new.state(10, 2, 4, 1)
new.state(10, 2, 4, 1, 1)
new.state(10, 3, 3, 1, 1)
maintenance(1)
i
i = 1
i <- 0.2
maintenance(2)
maintenance(1)
maintenance(20)
production(20)
regulation(15, 5)
investment(3, 4)
regulation(15, 9)
new.state <- function(nh, ns, s, t, d){
nh.l = ifelse(F$repro[t] == "no" | nh < nh.repro | ns < ns.repro, 0, (nh - F$mh[t])*nh.larva)
ns.l = ifelse(F$repro[t] == "no" | nh < nh.repro | ns < ns.repro, 0, (ns - F$ms[t])*ns.larva)
new.ns = chop((ns - F$ms[t] - ns.larva + production(s)), 0, ns.max)
if (d == 1){ # If d = 1, there is no investment or regulation
new.nh = chop((nh - nh.larva - F$mh[t] + F$N[t] - maintenance(s)), 0, nh.max)
new.s = s
} else if (d > 1 & d <= (n+1)){ # If d is between 2 and N+1, there is investment
new.nh = chop((nh - F$mh[t] - nh.l + F$N[t] - maintenance(s) - (d-1)), 0, nh.max)
new.s = chop((investment(s, d)), 0, s.max)
} else { # If d is greater than N+1, there is regulation
new.nh = chop((nh - F$mh[t] - nh.l + F$N[t] - maintenance(s) - (d-n-1)), 0 , nh.max)
new.s = chop((regulation(s, d)), 0, s.max)
}
output = data.frame(new.nh, new.ns, new.s)
return(output)
}
new.state(10, 3, 3, 1, 1)
source("Model_3/functions_3.R")
source("interpolate.R")
source("Model_3/test_parameters.R")
parameters <- c(model.name, nh.max, ns.max, s.max, nh.repro, ns.repro, nh.crit.pupae, nh.crit.adult, nh.larva, ns.larva,
mh.pupae, mh.adult, ms.pupae, ms.adult, ex.surv.pupae, ex.surv.adult, T, n, m, i, j, k, l, Q)
parameters <- t(as.data.frame(parameters))
colnames(parameters) <- c("model.name", "nh.max", "ns.max", "s.max", "nh.repro", "ns.repro", "nh.crit.pupae", "nh.crit.adult", "nh.larva", "ns.larva",
"mh.pupae", "mh.adult", "ms.pupae", "ms.adult", "ex.surv.pupae", "ex.surv.adult", "T", "n", "m", "i", "j", "k", "l", "Q")
save(parameters, file = paste("Model_3/parameters_", model.name, ".RData", sep = ""))
time.step <- c(1:61)
F <- as.data.frame(time.step)%>%
mutate(stage = ifelse(time.step <= 13, "pupae", "adult"))%>%
mutate(repro = ifelse(time.step %in% seq(from = 21, to = 61, by = 4), "yes", "no"))%>%
mutate(N = ifelse(stage == "pupae", 0, n))%>%
mutate(mh = ifelse(stage == "pupae", mh.pupae, mh.adult), ms = ifelse(stage == "pupae", ms.pupae, ms.adult))%>%
mutate(ex.surv = ifelse(stage == "pupae", ex.surv.pupae, ex.surv.adult))%>%
mutate(nh.crit = ifelse(stage == "pupae", nh.crit.pupae, nh.crit.adult))
######################################################## Dynamic Programming with for loops #######################################################
pb <- txtProgressBar(min = 0, max = ns.max*nh.max*s.max*(T-1), style = 3)
V <- array(data = NA, dim = c((T), nh.max, ns.max, s.max)) # Empty fitness array, to be populated with values from T back to 1
d.opt <- array(data = NA, dim = c((T-1), nh.max, ns.max, s.max)) # Empty array for best decisions at each state and time
V[T,,,] <- 0 # terminal fitness function
for (t in (T-1):1){ # Iterates backwards in time
for (nh in 1:nh.max){
for (ns in 1:ns.max){
for (s in 1:s.max){
H = array(data = NA, dim = (2*n+1)) # Empty reproductive value array (for one state)
for (d in 1:(2*n+1)){
nh. = as.numeric(new.state(nh, ns, s, t, d)[1]) # Calculate new values for states
ns. = as.numeric(new.state(nh, ns, s, t, d)[2])
s. = as.numeric(new.state(nh, ns, s, t, d)[3])
H[d] = B(nh, ns, t) + S(nh., t)*interpolate(V, chop(nh., 1, nh.max), chop(ns., 1, ns.max), chop(s., 1, s.max), (t+1))
}
V[t, nh, ns, s] <- max(H) # define fitness as maximum of the reproductive values
d.opt[t, nh, ns, s] <- which.max(H) # Set best decision as the one which maximises fitness
setTxtProgressBar(pb, (s-1) + (ns-1)*s.max + (nh-1)*ns.max*s.max + (T-t-1)*nh.max*ns.max*s.max)
}
}
}
}
d.opt. <- melt(d.opt)
names(d.opt.) <- c("time.step", "Nh", "Ns", "sym.pop", "decision")
d.opt.plot <- ggplot(data = d.opt., aes(time.step, sym.pop, fill = decision)) +
geom_tile()+
facet_grid(Nh ~ Ns)+
scale_fill_gradient(low = "#80CBC4", high = "#00695C")+
theme(axis.title.y.right = element_text("Nh"),
axis.title.x.top = element_text("Ns"))
d.opt.plot
sim.plot <- ggplot(NULL, aes(x = time.step, y = sym.pop)) # empty plot to be populated with simulation runs
for (q in 1:Q){
sim <- data.frame(time.step = integer(), nh.reserves = integer(), ns.reserves = integer(), sym.pop = integer(), decision = integer())%>%
# empty data frame to be populated with state values and allocations
add_row(time.step = 1,  nh.reserves = chop(round(rnorm(1, mean = (nh.max), sd = 0.5)), 0, nh.max),
ns.reserves = chop(round(rnorm(1, mean = (ns.max/2), sd = 0.5)), 0, ns.max),
sym.pop = chop(round(rnorm(1, mean = (s.max/3), sd = 0.5)), 0, s.max), decision = NA) # initial state values chosen at random
for (t in 1:(T-1)){
if (sim$nh.reserves[t] >= F$nh.crit[t] & sim$ns.reserves[t] >= 1 & sim$sym.pop[t] >= 1){
d = interpolate(d.opt, sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t) # extract optimum allocation amount based on state values
sim$decision[t] = d
nh. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[1])
ns. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[2])
s. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[3])
sim <- add_row(sim, time.step = (t+1), nh.reserves = nh., ns.reserves = ns., sym.pop = s., decision = NA) # populate data frame with new state values
print(t)}
else {
break # if reserves get to zero, stop the simulation
}
}
print(sim)
sim.plot <- sim.plot+
geom_line(data = sim, aes(x = time.step, y = sym.pop, group = 1)) # add data frame to plot
}
sim.plot <- sim.plot+
labs(x = "time step", y = "symbiont density")
source("Model_3/test_parameters.R")
sim.plot <- ggplot(NULL, aes(x = time.step, y = sym.pop)) # empty plot to be populated with simulation runs
for (q in 1:Q){
sim <- data.frame(time.step = integer(), nh.reserves = integer(), ns.reserves = integer(), sym.pop = integer(), decision = integer())%>%
# empty data frame to be populated with state values and allocations
add_row(time.step = 1,  nh.reserves = chop(round(rnorm(1, mean = (nh.max), sd = 0.5)), 0, nh.max),
ns.reserves = chop(round(rnorm(1, mean = (ns.max/2), sd = 0.5)), 0, ns.max),
sym.pop = chop(round(rnorm(1, mean = (s.max/3), sd = 0.5)), 0, s.max), decision = NA) # initial state values chosen at random
for (t in 1:(T-1)){
if (sim$nh.reserves[t] >= F$nh.crit[t] & sim$ns.reserves[t] >= 1 & sim$sym.pop[t] >= 1){
d = interpolate(d.opt, sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t) # extract optimum allocation amount based on state values
sim$decision[t] = d
nh. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[1])
ns. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[2])
s. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[3])
sim <- add_row(sim, time.step = (t+1), nh.reserves = nh., ns.reserves = ns., sym.pop = s., decision = NA) # populate data frame with new state values
print(t)}
else {
break # if reserves get to zero, stop the simulation
}
}
print(sim)
sim.plot <- sim.plot+
geom_line(data = sim, aes(x = time.step, y = sym.pop, group = 1)) # add data frame to plot
}
sim.plot <- sim.plot+
labs(x = "time step", y = "symbiont density")
sim.plot
source("Model_3/test_parameters.R")
parameters <- c(model.name, nh.max, ns.max, s.max, nh.repro, ns.repro, nh.crit.pupae, nh.crit.adult, nh.larva, ns.larva,
mh.pupae, mh.adult, ms.pupae, ms.adult, ex.surv.pupae, ex.surv.adult, T, n, m, i, j, k, l, Q)
parameters <- t(as.data.frame(parameters))
colnames(parameters) <- c("model.name", "nh.max", "ns.max", "s.max", "nh.repro", "ns.repro", "nh.crit.pupae", "nh.crit.adult", "nh.larva", "ns.larva",
"mh.pupae", "mh.adult", "ms.pupae", "ms.adult", "ex.surv.pupae", "ex.surv.adult", "T", "n", "m", "i", "j", "k", "l", "Q")
save(parameters, file = paste("Model_3/parameters_", model.name, ".RData", sep = ""))
time.step <- c(1:61)
F <- as.data.frame(time.step)%>%
mutate(stage = ifelse(time.step <= 13, "pupae", "adult"))%>%
mutate(repro = ifelse(time.step %in% seq(from = 21, to = 61, by = 4), "yes", "no"))%>%
mutate(N = ifelse(stage == "pupae", 0, n))%>%
mutate(mh = ifelse(stage == "pupae", mh.pupae, mh.adult), ms = ifelse(stage == "pupae", ms.pupae, ms.adult))%>%
mutate(ex.surv = ifelse(stage == "pupae", ex.surv.pupae, ex.surv.adult))%>%
mutate(nh.crit = ifelse(stage == "pupae", nh.crit.pupae, nh.crit.adult))
######################################################## Dynamic Programming with for loops #######################################################
pb <- txtProgressBar(min = 0, max = ns.max*nh.max*s.max*(T-1), style = 3)
V <- array(data = NA, dim = c((T), nh.max, ns.max, s.max)) # Empty fitness array, to be populated with values from T back to 1
d.opt <- array(data = NA, dim = c((T-1), nh.max, ns.max, s.max)) # Empty array for best decisions at each state and time
V[T,,,] <- 0 # terminal fitness function
for (t in (T-1):1){ # Iterates backwards in time
for (nh in 1:nh.max){
for (ns in 1:ns.max){
for (s in 1:s.max){
H = array(data = NA, dim = (2*n+1)) # Empty reproductive value array (for one state)
for (d in 1:(2*n+1)){
nh. = as.numeric(new.state(nh, ns, s, t, d)[1]) # Calculate new values for states
ns. = as.numeric(new.state(nh, ns, s, t, d)[2])
s. = as.numeric(new.state(nh, ns, s, t, d)[3])
H[d] = B(nh, ns, t) + S(nh., t)*interpolate(V, chop(nh., 1, nh.max), chop(ns., 1, ns.max), chop(s., 1, s.max), (t+1))
}
V[t, nh, ns, s] <- max(H) # define fitness as maximum of the reproductive values
d.opt[t, nh, ns, s] <- which.max(H) # Set best decision as the one which maximises fitness
setTxtProgressBar(pb, (s-1) + (ns-1)*s.max + (nh-1)*ns.max*s.max + (T-t-1)*nh.max*ns.max*s.max)
}
}
}
}
d.opt. <- melt(d.opt)
names(d.opt.) <- c("time.step", "Nh", "Ns", "sym.pop", "decision")
d.opt.plot <- ggplot(data = d.opt., aes(time.step, sym.pop, fill = decision)) +
geom_tile()+
facet_grid(Nh ~ Ns)+
scale_fill_gradient(low = "#80CBC4", high = "#00695C")+
theme(axis.title.y.right = element_text("Nh"),
axis.title.x.top = element_text("Ns"))
d.opt.plot
sim.plot <- ggplot(NULL, aes(x = time.step, y = sym.pop)) # empty plot to be populated with simulation runs
for (q in 1:Q){
sim <- data.frame(time.step = integer(), nh.reserves = integer(), ns.reserves = integer(), sym.pop = integer(), decision = integer())%>%
# empty data frame to be populated with state values and allocations
add_row(time.step = 1,  nh.reserves = chop(round(rnorm(1, mean = (nh.max), sd = 1)), 0, nh.max),
ns.reserves = chop(round(rnorm(1, mean = (ns.max), sd = 1)), 0, ns.max),
sym.pop = chop(round(rnorm(1, mean = (s.max/5), sd = 1)), 0, s.max), decision = NA) # initial state values chosen at random
for (t in 1:(T-1)){
if (sim$nh.reserves[t] >= F$nh.crit[t] & sim$ns.reserves[t] >= 1 & sim$sym.pop[t] >= 1){
d = interpolate(d.opt, sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t) # extract optimum allocation amount based on state values
sim$decision[t] = d
nh. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[1])
ns. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[2])
s. = as.numeric(new.state(sim$nh.reserves[t], sim$ns.reserves[t], sim$sym.pop[t], t, d)[3])
sim <- add_row(sim, time.step = (t+1), nh.reserves = nh., ns.reserves = ns., sym.pop = s., decision = NA) # populate data frame with new state values
print(t)}
else {
break # if reserves get to zero, stop the simulation
}
}
print(sim)
sim.plot <- sim.plot+
geom_line(data = sim, aes(x = time.step, y = sym.pop, group = 1)) # add data frame to plot
}
sim.plot <- sim.plot+
labs(x = "time step", y = "symbiont density")
sim.plot
preoduction(2)
production(2)
ms.pupae
maintenance(1)
mh.pupae
new.state(20, 1, 1, 1)
new.state(20, 1, 1, 1, 1)
new.state(20, 2, 1, 1, 1)
new.state(20, 3, 1, 1, 1)
source("Model_3/functions_3.R")
source("interpolate.R")
source("Model_3/test_parameters.R")
parameters <- c(model.name, nh.max, ns.max, s.max, nh.repro, ns.repro, s.repro, nh.crit.pupae, nh.crit.adult, nh.larva, ns.larva,
mh.pupae, mh.adult, ms.pupae, ms.adult, ex.surv.pupae, ex.surv.adult, T, n, m, i, j, k, l, Q)
parameters <- t(as.data.frame(parameters))
colnames(parameters) <- c("model.name", "nh.max", "ns.max", "s.max", "nh.repro", "ns.repro", "s.repro", "nh.crit.pupae", "nh.crit.adult", "nh.larva", "ns.larva",
"mh.pupae", "mh.adult", "ms.pupae", "ms.adult", "ex.surv.pupae", "ex.surv.adult", "T", "n", "m", "i", "j", "k", "l", "Q")
save(parameters, file = paste("Model_3/parameters_", model.name, ".RData", sep = ""))
time.step <- c(1:61)
F <- as.data.frame(time.step)%>%
mutate(stage = ifelse(time.step <= 13, "pupae", "adult"))%>%
mutate(repro = ifelse(time.step %in% seq(from = 21, to = 61, by = 4), "yes", "no"))%>%
mutate(N = ifelse(stage == "pupae", 0, n))%>%
mutate(mh = ifelse(stage == "pupae", mh.pupae, mh.adult), ms = ifelse(stage == "pupae", ms.pupae, ms.adult))%>%
mutate(ex.surv = ifelse(stage == "pupae", ex.surv.pupae, ex.surv.adult))%>%
mutate(nh.crit = ifelse(stage == "pupae", nh.crit.pupae, nh.crit.adult))
######################################################## Dynamic Programming with for loops #######################################################
pb <- txtProgressBar(min = 0, max = ns.max*nh.max*s.max*(T-1), style = 3)
V <- array(data = NA, dim = c((T), nh.max, ns.max, s.max)) # Empty fitness array, to be populated with values from T back to 1
d.opt <- array(data = NA, dim = c((T-1), nh.max, ns.max, s.max)) # Empty array for best decisions at each state and time
V[T,,,] <- 0 # terminal fitness function
for (t in (T-1):1){ # Iterates backwards in time
for (nh in 1:nh.max){
for (ns in 1:ns.max){
for (s in 1:s.max){
H = array(data = NA, dim = (2*n+1)) # Empty reproductive value array (for one state)
for (d in 1:(2*n+1)){
nh. = as.numeric(new.state(nh, ns, s, t, d)[1]) # Calculate new values for states
ns. = as.numeric(new.state(nh, ns, s, t, d)[2])
s. = as.numeric(new.state(nh, ns, s, t, d)[3])
H[d] = B(nh, ns, t) + S(nh., t)*interpolate(V, chop(nh., 1, nh.max), chop(ns., 1, ns.max), chop(s., 1, s.max), (t+1))
}
V[t, nh, ns, s] <- max(H) # define fitness as maximum of the reproductive values
d.opt[t, nh, ns, s] <- which.max(H) # Set best decision as the one which maximises fitness
setTxtProgressBar(pb, (s-1) + (ns-1)*s.max + (nh-1)*ns.max*s.max + (T-t-1)*nh.max*ns.max*s.max)
}
}
}
}
warnings()
